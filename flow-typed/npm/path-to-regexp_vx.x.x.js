// flow-typed signature: 07217a785921b69bbef4f2f923609680
// flow-typed version: <<STUB>>/path-to-regexp_v6.2.0/flow_v0.143.0

/**
 * This is an autogenerated libdef stub for:
 *
 *   'path-to-regexp'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

declare module 'path-to-regexp' {
  declare interface ParseOptions {

    /**
    * Set the default delimiter for repeat parameters. (default: `'/'`)
    */
    delimiter?: string,

    /**
    * List of characters to automatically consider prefixes when parsing.
    */
    prefixes?: string,
  } 
  /**
  * Parse a string for the raw tokens.
  */
  declare function parse(str: string, options?: ParseOptions): Token[]
  declare interface TokensToFunctionOptions {

    /**
    * When `true` the regexp will be case sensitive. (default: `false`)
    */
    sensitive?: boolean,

    /**
    * Function for encoding input strings for output.
    */
    encode?: (value: string, token: Key) => string,

    /**
    * When `false` the function can produce an invalid (unmatched) path. (default: `true`)
    */
    validate?: boolean,
  } 
  /**
  * Compile a string to a template function for the path.
  */
  declare function compile<P: {[key: string]: any}>(
    str: string,
    options?: ParseOptions & TokensToFunctionOptions
  ): PathFunction<P>
  declare type PathFunction<P: {[key: string]: any}= {[key: string]: any}> = (data?: P) => string;
  /**
  * Expose a method for transforming tokens into the path function.
  */
  declare function tokensToFunction<P: {[key: string]: any}>(
    tokens: Token[],
    options?: TokensToFunctionOptions
  ): PathFunction<P>
  declare interface RegexpToFunctionOptions {

    /**
    * Function for decoding strings for params.
    */
    decode?: (value: string, token: Key) => string,
  } 
  /**
  * A match result contains data about the path match.
  */
  declare interface MatchResult<P: {[key: string]: any}= {[key: string]: any}> {
    path: string,
    index: number,
    params: P,
  } 
  /**
  * A match is either `false` (no match) or a match result.
  */
  declare type Match<P: {[key: string]: any}= {[key: string]: any}> = false | MatchResult<P>;
  /**
  * The match function takes a string and returns whether it matched the path.
  */
  declare type MatchFunction<P: {[key: string]: any}= {[key: string]: any}> = (path: string) => Match<P>;
  /**
  * Create path match function from `path-to-regexp` spec.
  */
  declare function match<P: {[key: string]: any}>(
    str: Path,
    options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions
  ): MatchFunction<P>

  /**
  * Create a path match function from `path-to-regexp` output.
  */
  declare function regexpToFunction<P: {[key: string]: any}>(
    re: RegExp,
    keys: Key[],
    options?: RegexpToFunctionOptions
  ): MatchFunction<P>

  /**
  * Metadata about a key.
  */
  declare interface Key {
    name: string | number,
    prefix: string,
    suffix: string,
    pattern: string,
    modifier: string,
  } 
  /**
  * A token is a string (nothing special) or key metadata (capture group).
  */
  declare type Token = string | Key;
  declare interface TokensToRegexpOptions {

    /**
    * When `true` the regexp will be case sensitive. (default: `false`)
    */
    sensitive?: boolean,

    /**
    * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)
    */
    strict?: boolean,

    /**
    * When `true` the regexp will match to the end of the string. (default: `true`)
    */
    end?: boolean,

    /**
    * When `true` the regexp will match from the beginning of the string. (default: `true`)
    */
    start?: boolean,

    /**
    * Sets the final character for non-ending optimistic matches. (default: `/`)
    */
    delimiter?: string,

    /**
    * List of characters that can also be "end" characters.
    */
    endsWith?: string,

    /**
    * Encode path tokens for use in the `RegExp`.
    */
    encode?: (value: string) => string,
  } 
  /**
  * Expose a function for taking tokens and returning a RegExp.
  */
  declare function tokensToRegexp(tokens: Token[], keys?: Key[], options?: TokensToRegexpOptions): RegExp

  /**
  * Supported `path-to-regexp` input types.
  */
  declare type Path = string | RegExp | Array<string | RegExp>;
  /**
  * Normalize the given path string, returning a regular expression.
  * 
  * An empty array can be passed in for the keys, which will hold the
  * placeholder key descriptions. For example, using `/user/:id`, `keys` will
  * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
  */
  declare function pathToRegexp(
    path: Path,
    keys?: Key[],
    options?: TokensToRegexpOptions & ParseOptions
  ): RegExp

}

