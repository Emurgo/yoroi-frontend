// @flow

// Handle restoring wallets that follow the v2 addressing scheme (bip44)

import _ from 'lodash';
import {
  discoverAllAddressesFrom,
  generateAddressBatch
} from './lib/adaAddressProcessing';
import {
  saveAsAdaAddresses,
} from './adaAddress';
import type {
  AddressType,
  AdaWallet,
  AdaWalletParams
} from './adaTypes';
import {
  Logger,
  stringifyError
} from '../../utils/logging';
import {
  saveCryptoAccount,
  createStoredWallet,
  getLastReceiveAddressIndex,
  saveLastReceiveAddressIndex
} from './adaLocalStorage';
import type {
  CryptoAccount
} from './adaLocalStorage';
import { createAdaWallet } from './adaWallet';
import { createCryptoAccount } from './adaAccount';
import type { ConfigType } from '../../../config/config-types';
import type { FilterFunc } from './lib/state-fetch/types';

declare var CONFIG: ConfigType;
const addressScanSize = CONFIG.app.addressScanSize;
const addressRequestSize = CONFIG.app.addressRequestSize;

/** Restore all addresses and caches the results locally
 * Note: addresses may not be detected if generated by a wallet that doesn't follow bip44
 */
export async function restoreAdaWallet(
  { walletPassword, walletInitData }: AdaWalletParams,
  checkAddressesInUse: FilterFunc,
): Promise<AdaWallet> {
  try {
    // recover master key
    const [adaWallet, masterKey] = createAdaWallet({ walletPassword, walletInitData });
    // always create the 0th account
    const cryptoAccount = createCryptoAccount(masterKey, walletPassword, 0);

    await restoreTransactionsAndSave(cryptoAccount, adaWallet, masterKey, checkAddressesInUse);
    return adaWallet;
  } catch (error) {
    Logger.error('restoreAdaWallet::restoreAdaWallet error: ' +
      stringifyError(error));
    throw error;
  }
}

/** Restore transactions and Save wallet + masterKey + cryptoAccount to localstorage */
export async function restoreTransactionsAndSave(
  cryptoAccount: CryptoAccount,
  adaWallet: AdaWallet,
  masterKey?: string,
  checkAddressesInUse: FilterFunc,
): Promise<void> {
  // save wallet info in localstorage
  saveCryptoAccount(cryptoAccount);
  createStoredWallet(adaWallet, masterKey);

  /**
   * If the user has no internet connection and scanning fails,
   * we need to initialize our wallets with the bip44 gap size directly
   *
   * Otherwise the generated addresses won't be added to the wallet at all.
   * This would violate our bip44 obligation to maintain a unused address gap
   *
   * Example:
   * If we throw, no new addresses will be added
   * so the user's balance would be stuck at 0 until they reinstall Yoroi.
   */
  saveInitialAddresses(cryptoAccount, 'External');
  saveInitialAddresses(cryptoAccount, 'Internal');

  scanAndSaveAddresses(cryptoAccount, 'External', -1, checkAddressesInUse);
  scanAndSaveAddresses(cryptoAccount, 'Internal', -1, checkAddressesInUse);
}

async function saveInitialAddresses(
  cryptoAccount: CryptoAccount,
  addressType: AddressType,
) {
  const addressesIndex = _.range(
    0,
    addressScanSize
  );

  const initialAddresses = generateAddressBatch(
    addressesIndex,
    cryptoAccount.root_cached_key,
    addressType
  );

  await saveAsAdaAddresses(
    cryptoAccount,
    initialAddresses,
    0,
    addressType
  );
}

export async function scanAndSaveAddresses(
  cryptoAccount: CryptoAccount,
  addressType: AddressType,
  startIndex: number,
  checkAddressesInUse: FilterFunc,
): Promise<void> {
  const addressesToSave = await discoverAllAddressesFrom(
    cryptoAccount.root_cached_key,
    addressType,
    startIndex,
    addressScanSize,
    addressRequestSize,
    checkAddressesInUse,
  );

  // Save all addresses in local DB
  if (addressesToSave.length !== 0) {
    await saveAsAdaAddresses(
      cryptoAccount,
      addressesToSave,
      startIndex + 1,
      addressType
    );
  }

  /**
   * Note; we have to handle updating the lastReceiveAddressIndex in this function
   * as it is the only place that can confidentally disambiguate which addresses are
   * explicitly needed and which ones are just present for bip44 compliance
   */
  if (addressType === 'External') {
    const currLast = getLastReceiveAddressIndex();
    const maxFound = (startIndex + addressesToSave.length - addressScanSize);
    if (maxFound > currLast) {
      saveLastReceiveAddressIndex(maxFound);
    }
  }
}
