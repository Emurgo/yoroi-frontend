# Abstract

Private keys can be used to sign arbitrary data. If you have the public key, you can verify the data was signed by the owner of the private key. This is how transaction signing works internally but its utility is not limited to transactions. This document tries to set a standard for how to represent and verify signed messages for Cardano.

# Motivation

Most common use cases:

1) Proving ownership of a set addresses (possibly to prove ownership of more then X Ada)
1) Proving ownership of addresses used in a transaction
1) Proving ownership of an identity or other off-chain data with a public key attached to it

# Requirements

On top being usable for all cases mentioned in *Motivation*, we also desire

### Engineering requirements

This standard needs to work well with hardware wallets

- E1 - Low runtime memory environment
- E2 - Low app size environment (cannot implement every cryptographic algorithm on the device or app size would be too big)
- E3 - Works well with limited display (some hardware wallets cannot display long text and cannot display UTF8)

### Security requirements

- S1 - To avoid messages accidentally being treated as a different type (such as a transaction, block, etc.), bytes signed in this specification cannot start with any [existing prefix](https://github.com/input-output-hk/rust-cardano/blob/2e924a4457203fa6b19f409cb897d90cd6b699f6/cardano/src/tags.rs)

# Related specifications

### Requirement Levels [[RFC 2119](https://tools.ietf.org/html/rfc2119)]

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

### Concise Binary Object Representation (CBOR) [[RFC 7049](https://tools.ietf.org/html/rfc7049)]

CBOR is a way to serialize structured data in a more compact way than what is allowed by JSON. IT is widely used across the Cardano ecosystem and so we use it to encode the data for this specification.

There is currently no standard CBOR grammar available for use by specifications. The CBOR structures are therefore described in prose.

| Prose | description           | Major type | value |
|-------|-----------------------|------------|-------|
| uint  | unsigned int          |      0     |   -   |
| nint  | negative int          |      1     |   -   |
| bstr  | byte string           |      2     |   -   |
| tstr  | UTF8 string           |      3     |   -   |
| array | arbitrary size array  |      4     |   -   |
| map   | arbitrary size map    |      5     |   -   |
| tag   | semantic tag for data |      6     |   -   |
| false |                       |      7     |   20  |
| true  |                       |      7     |   21  |
| nil   |                       |      7     |   22  |

Some additional shorthand notations is used:

- any - non-specific value that permits all CBOR values to be placed here.
- int - an unsigned integer or a negative integer.
- FOO / BAR - indicates that either FOO or BAR can appear here
- bool - false / true
- label - int / tstr
- [+ FOO] - type FOO appears one or more times in an array
- [* FOO] - type FOO appears zero or more times in an array
- [? FOO] - type FOO appears 0 or 1 time in an array

### *CBOR Object Signing and Encryption (COSE)* [[RFC 8152](https://tools.ietf.org/html/rfc8152)] 

This is a standard for how to use CBOR for message signing. It is based on the JSON equivalent *JSON Object Signing and Encryption* [RFC 7520](https://tools.ietf.org/html/rfc7520). 

We base our construction on COSE because all Cardano libraries already depend on CBOR due to its use in the base protocol (which means we don't need to introduce a new library). It is also more compact, which is useful in case data generated by this standard ever needs to be stored on-chain.

Note that we do NOT follow the COSE specification exactly for the following reason:

- We need to restrict the number of algorithms used to only ones that would already be required to provide base Cardano functionality (see E1).
- We need to prepend a CBOR tag to the beginning of the data we will sign (see S1)

### *CBOR Web Token (CWT)* [[RFC 8392](https://tools.ietf.org/html/rfc8392)]

This is a standard for pre-defined header elements for message signing based on the equivalent standard for JSON (*JWT* [[RFC 7519](https://tools.ietf.org/html/rfc7519)]). This allows us to standardize notions of concepts like expiration time of a signed message.

### Cardano HD master node derivation from a master seed [[SLIP-0023](https://github.com/satoshilabs/slips/blob/4b5ee84cd5e6d588a4672737138c46b1ff0b0a4c/slip-0023.md)]

This standard described how to represent both what are called `v1` and `v2` addresses in Cardano. 

Due to the complexity of the `v1` scheme and the fact that it will be deprecated, it will NOT be included in this spec. Although `v2` addresses will also be deprecated, they are simple enough to easily include in our specification.

Our message signing scheme needs a way to map public keys

### *Bech32 Address Format* [[BIP-173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki)]

BECH32 is a standard for encoding addresses such that they

- Are human readable (both in length and contain a common prefix)
- Can easily be displayed in a QR code
- Contain error detection through a BCH checksum

Cardano uses BECH32 in what it called `v3` addresses defined in [CIP-001](https://github.com/input-output-hk/implementation-decisions/blob/master/text/0001-address.md)

Although `v3` is relevant to us for encoding public keys into addresses, we do not use `bech32`'s scheme for encoding in this specification. This is because

- The payload may be too big to reasonably encode in a QR code so the benefit of using base32 are limited.
- BCH checksums are not made for large payloads and additionally the polynomial used has to be fine-tuned for the expected length (but the length of our payload varies too much in this spec)

### CRC32

Although there is no specification for CRC32 and many variations exist, in Cardano we use the CRC-32-IEEE variation. You can find a C implementation [here](https://github.com/cardano-foundation/ledger-app-cardano/blob/3f784d23c1b87df73cda552ef01428d3e2733237/src/crc32.c#L6)

### Blake2b [[RFC 7693](https://tools.ietf.org/html/rfc7693)]

Blake2b is a hash algorithm used commonly in Cardano. Notably, Blake2b-224, Blake2b-256 and Blake2b512 are used depending on the context.

### base64url [[RFC 4648 section 5](https://tools.ietf.org/html/rfc4648#section-5)]

`base64url` allows to encode bytes in a human-readable format that is also safe to pass in URLs.

### Other blockchain standards

Other blockchains have existing specifications for message signing, but they mostly revolve around scripts trying to validate messages. We don't leverage any of their work in particular but it may be of interest.

- [BIP-137](https://github.com/bitcoin/bips/blob/master/bip-0137.mediawiki) - simply scheme for message signing that works with P2PKH, P2PSH and bech32
- [BIP-322](https://github.com/kallewoof/bips/blob/master/bip-0322.mediawiki) - reuses Bitcoin script to process a generic signed message format

- [EIP-191](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-191.md) - encode data for Ethereum contracts
- [EIP-712](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md) - encode structs for Ethereum contracts

# Existing Code

### Cryptography

Cardano already allows message signing within the WASM bindings. Notably,

1) [sign](https://github.com/input-output-hk/js-cardano-wasm/blob/master/cardano-wallet/src/lib.rs#L177)
2) [verify](https://github.com/input-output-hk/js-cardano-wasm/blob/master/cardano-wallet/src/lib.rs#L232)

You can see an example of these two functions [here](https://repl.it/repls/GlossyDarkgreenMethod)

Even if you use cryptographically sound `sign` and `verify` functions, you still have the following problems:

1) No human-recognizable prefix
0) No error detection
0) User could accidentally sign a transaction or a block thinking it's harmless data

We also have a risk of a few different kinds of replay attacks

4) A dapp asks person A to sign "BOB" and then another dapp asks user B to sign "BOB". B can just use the signature from A
0) A dapp asks person A to sign "BOB" on testnet chain. Person B then sends this signed message to the same dapp running on mainnet (same argument applies to sidechains)

# Message Signing Format

Everywhere in this spec where we mention CBOR encoding, it MUST be done using Canonical CBOR as described in [RFC 7049 section 3.9](https://tools.ietf.org/html/rfc7049#section-3.9). Otherwise, signature may be rejected purely for encoding reasons.

## Signing and Verification

### Overview

First we will show a very basic example of the structure to help the reader understand the definitions that comes after

```
[
  h'',            # protected header   - bstr
  {},             # unprotected header - map
  h'',            # message to sign    - bstr / nil
  [               # signature array    - array
    [             # first signature    - array
      h''         # protected          - bstr
      {},         # unprotected        - map
      h''         # signature          - bstr
    ]
  ]
]
```

You can see the structure has two layers -- both containing a `protected` and an `unprotected` section. Items inside `protected` are part of the data signed while `unprotected` is meant to annotate the COSE structure (for example add annotations as you pass a message across a stack). Items MUST NOT be duplicated.

You can find more complete definitions of `protected` and `unprotected` in [RFC 8152 section-3](https://tools.ietf.org/html/rfc8152#section-3) and you can see some the reserved entries (called `Generic_Headers`) in the maps in [RFC 8152 section-3.1](https://tools.ietf.org/html/rfc8152#section-3.1).

Note: `payload` can be `nil`. This means that the payload is known by both the signer and the verifier and therefore doesn't need to be encoded.

For your convenience, the structure is provided here:

```
empty_or_serialized_map = bstr .cbor header_map / bstr .size 0

header_map = {
    Generic_Headers,   # reserved headers (see section 3.1)
    * label => values  # any number of string labels for application-specific purpose.
}

Headers = (
    protected : empty_or_serialized_map,
    unprotected : header_map
)

# signature layer
COSE_Signature =  [
    Headers,
    signature : bstr
]

# if signing with just ONE key
COSE_Sign1 = [
    Headers,
    payload : bstr / nil,
    signature : bstr
]

# if signing with >1 key
COSE_Sign = [
    Headers,
    payload : bstr / nil,
    signatures : [+ COSE_Signature]
]

SIGN_TAG = 18 | 98   # unique prefix so we can infer which structure is used
signed_message = 98 ( COSE_SIGN) / 18 ( COSE_Sign1)
```

### Signing and Verification target format

Instead of signing the full structure, we instead sign the following type which is derived from the structure

```
Sig_structure = SIGN_TAG ([
  context : "Signature" / "Signature1" / "CounterSignature",    # explained below
  body_protected : empty_or_serialized_map,                     # protected from layer 1
  ? sign_protected : empty_or_serialized_map,                   # not present in Sign1 case
  external_aad : bstr,                                          # explanation below
  payload : bstr
])
```

⚠️ Note: We add a `SIGN_TAG` not present inside `Sig_structure` in the original COSE specification. This is because we want to avoid a user accidentally signing a byte sequence that may be confused as a different structure with different meaning (notably, we want to avoid the user accidentally signing a transaction or a block). The way we do this is that Cardano enforces that every signable object MUST start with a unique prefix. You can find a current list in the Rust codebase [here](https://github.com/input-output-hk/rust-cardano/blob/2e924a4457203fa6b19f409cb897d90cd6b699f6/cardano/src/tags.rs) and the Haskell codebase [here](https://github.com/input-output-hk/cardano-sl/blob/ccca8b346413f12e9fad8cab4c855e69669a2151/crypto/Pos/Crypto/Signing/Tag.hs#L15).

We therefore introduce a set of new tags based off `Table 1` in [RFC 8152](https://tools.ietf.org/html/rfc8152).

| CBOR Tag | Type          |
|----------|---------------|
| 98       | COSE_Sign     |
| 18       | COSE_Sign1    |
| 96       | COSE_Encrypt  |
| 16       | COSE_Encrypt0 |
| 97       | COSE_Mac      |
| 17       | COSE_Mac0     |

Note that we introduce tags that are not used for this specific specification. This is just to reserve them in case they are used in the future.

COSE allows you to use un-tagged versions of all the structures. However for this spec you MUST always use the tagged version.

The `external_aad` allows an application to ask the user to sign some extra data but NOT put it inside the COSE structure (only as part of the data to sign). Defaults to `h''`. You can read more about this at [RFC 8152 section-4.3](https://tools.ietf.org/html/rfc8152#section-4.3).

The `context` is meant to encode what structure was used for the COSE request. `CounterSignature` is explained in a later section of this specification.

### Signing and Verification process

To be able to effectively verify we need two things:

1) P1 - (optional) knowledge of the relation of a public key and a Cardano address
1) P2 - Knowledge of which algorithm was used to sign

For `P1`, just knowing the public key is not sufficient to know the address (which we need to know if we want to prove ownership of a UTXO or transaction). To resolve this, first we (optionally) add to the header some extra fields.

```
? address: bstr
? address_meta: array
```

Both `address` and `address_meta` are optional so that if the receiver knows this information or knows the mapping between the public key and the address, they can exclude these to reduce the payload size.

These are the values for `address_meta` depending on the address type

| type       | value    |
|------------|----------|
| v2         | [ bstr ] |
| v3 single  | [    ]   |
| v3 grouped | [ uint ] |

In the `v2` scheme, we need to specify the public key (since `address` only contains the `Blake2b-224` hash of the public key)
In the `v3` scheme, the public key is not encrypted or hashed in any way so it's not required in the *Single Address* case. In the *Grouped Address* case however, two public keys are specified in the address so we need to specify which one to use according to the following table.

| type         | value |
|--------------|-------|
| spending key | 0     |
| staking key  | 1     |

For `P2`, the algorithm that is used is uniquely determined by the public key used. *COSE* defines the `alg` pre-defined header to indicate which algorithm was used to sign/verify but we don't use this for the following reasons

1) We want to limit the number of allowed signing algorithms to exactly the set used in Cardano because of `E2`.
1) There is a 1-1 mapping between the pair `address`, `address_meta` and what signing algorithm is used and so this information would be redundant.
1) Allowed values in the `alg` field must be present in the [IANA COSE Algorithms registry](https://www.iana.org/assignments/cose/cose.xhtml#key-type) (and new entries have to be manually approved). This is not sufficient for us as we often have to use cutting edge cryptography specialized for our domain.

## Encryption

Although COSE defines multiple ways to encrypt, we simplify out spec to the two following cases:

1) Encrypted with the recipient's public key (called `key transport` in COSE spec)
2) Encrypted with a user-chosen password (called `passwords` in COSE spec)

In order to facilitate implementations in wallets, we limit the usage of these to the following

```
ChachaPoly = 1
Ed25519PubKey = 2

EncryptionType : uint = ChachaPoly / Ed25519PubKey
```

We will explain what this means shortly but you can find the full list of the types of encryption allowed by COSE at [RFC 8152 section 5.1.1](https://tools.ietf.org/html/rfc8152#section-5.1.1)

### Structure

The COSE specification is made to be composable -- that is you can have a plaintext that you wrap with a signature, then wrap with an encryption, then wrap with a signature again (and so on).

That means that for encryption in particular, it can either

1) Be used to encrypt plaintext directly
2) Be used to encrypt another COSE message

In this spec, we care about the case where you encrypt a `signed_message`

Here is the overall CBOR structure

```
# holds encrypted content itself
COSE_Encrypt = [
  Headers,
  ciphertext : bstr / nil, # contains encrypted signed_message
  recipients : [+COSE_recipient]
]

# holds encrypted keys the receiver can use to decrypt the content
COSE_recipient = [
  Headers,
  ciphertext : bstr / nil, # contains encrypted key to decrypt the COSE_Encrypt ciphertext
  ? recipients : [+COSE_recipient] # in case you need multiple rounds to get decryption key
]
```

To encrypt, the structure as a whole, we call our encryption method once for each level (root, recipient, etc.) recursively. For example, we encrypt the `signed_message` and put it in the `COSE_Encrypt` ciphertext, then we encrypt the decryption key and put it in the `COSE_recipient` ciphertext.

For the `Headers`,

- The `protected` fields MUST be empty. These are meant to be used with AEAD which we  don't need in this  specification (you can read more about it at [RFC 8152 section 5.3](https://tools.ietf.org/html/rfc8152#section-5.3)).
- The `unprotected` field MUST contain a `enc_type` label with value `EncryptionType` so that wallets can easily know what UI to display to users.

We define the encrypted payload as the union of two possibilities (defined below)

```
encrypted_message = PasswordEncryption / PubKeyEncryption
```

#### Password-based encryption

For password-based encryption we don't need a receiver field (anybody who knows the password can decrypt) so we instead use the following (simplified) structure

```
COSE_Encrypt0 = [
    Headers,
    ciphertext : bstr / nil,
]

PasswordEncryption = 16 (COSE_Encrypt0)
```

The `Headers` MUST have `enc_type: 1` in the `unprotected` field.

The `ciphertext` is simply the result of [the Yoroi encryption spec](https://github.com/Emurgo/yoroi-frontend/blob/737595fec5a89409aacef827d356c9a1605515c0/docs/specs/code/ENCRYPT.md) on the `signed_message`.

#### Public key based encryption

We only allow encrypting based on `ED25519 extended` public keys (the ones used for Cardano). To encrypt based on these public keys, you must

1) Compute a password consisting of 22 case-sensitive alphanumeric (a–z, A–Z, 0–9) characters (this gives you ~128 bits of entropy)

Now, for each receiver, you must

2) Compute an ephemeral key pair using `ED255519 extended`
1) Compute the shared DH secret between the private key from step (1) and the public key received (using the `exchange` functionality)
1) Compute the `Blake2b512` hash of the secret
1) Use this as the password to encrypt the password in (1) using [the Yoroi encryption spec](https://github.com/Emurgo/yoroi-frontend/blob/737595fec5a89409aacef827d356c9a1605515c0/docs/specs/code/ENCRYPT.md)

The structure will look like the following:

```
COSE_Encrypt = [
  Headers,
  ciphertext : bstr / nil, # contained signed_message encrypted with random password
  recipients : [+COSE_recipient]
]

COSE_recipient = [
  Headers,
  ciphertext : bstr / nil, # contains random password encrypted with shared secret
]

PubKeyEncryption = 96 (COSE_Encrypt)
```

The `Headers` for the body MUST have `enc_type: 2` in the `unprotected` field.

The `Headers` for the recipient MUST have a `eph_pub: bstr` label containing the public key of the ephemeral keypair.

## Multisig

TODO

## More headers

### Version

The `Headers` for the body MUST have `version: uint` in the `unprotected` field. See Changelog section for possible versions.

### CWT

CWT tags MAY be introduced inside `protected` headers as a CBOR map with the key `cwt`. It is RECOMMENDED to use these to avoid replay attacks

### Payload encoding

To solve `E3`, `signed_message` body header MUST contain `hashed: bool` as an `unprotected` header which defined whether or not we signed the `payload` OR the `Blake2b224` hash of the `payload`. The hash MUST be used in the following two cases

1) The size of the raw `payload` would otherwise be too big to fit in hardware wallet memory (see E1). Note that the exact size for which this is the case depends on the device.
1) The payload characters (ex: non-ASCII) that cannot be displayed on the hardware wallet device (see E3)

We RECOMMEND showing the user the full payload on the device if possible because it lowers the attack surface (otherwise the user has to trust that the hash of the payload was calculated correctly).

`Blake2b224` was chosen specifically because `224` bits is already a long string for hardware wallets.

## User-Facing Encoding

Once we have our top-level `encrypted_message` or `signed_message` we need to encode them in way that can be displayed to users (doesn't need to be stored and can be inferred just from the data)

We define the encoding in three parts `prefix || data || checksum` (where || means append)

### Prefix

We need a human-readable prefix. We use "CM" for "Cardano Message" followed by the message type:

- `encrypted_message`: `cme_`
- `signed_message`: `cms_`
- `mac_message`: `cmm_` (unused in this spec)

### Data

Data is simply the `base64url` encoding of the message

### Checksum

We use `CRC32` on the data for the checksum and store it as the `base64url` encoding of its network byte order representation.

# Other remarks

In this specification strongly prefer usage of unprotected headers vs protected headers when possible. This is because we have to limit the amount of data passed to a hardware wallet  to satisfy E1. If the only affect of an adversary changing an unprotected header only leads to the signature not matching, then it's best to leave it unprotected.

A public key SHOULD NOT be revealed if you plan to use its child non-hardened keys. It is both a privacy and a security risk (see [here](https://bitcoin.org/en/wallets-guide#hierarchical-deterministic-key-creation) for more detail).

# Reference implementation

- [COSE-JS](https://github.com/erdtman/cose-js) (warning: we very slightly deviate from COSE)

# Unresolved

This specification leaves the following unresolved

- Revocation

# Examples

TODO

# Changelog

| version | description     |
|---------|-----------------|
| 1       | initial version |
